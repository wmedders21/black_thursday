The final two methods of SalesAnalyst are quite similar in composition. In both cases, we begin with a call to a helper method `#helper_get_profitable_invoice_items`, which takes a Merchantâ€™s ID and returns all invoice items from invoices that have been paid for. From here the code diverges, if only slightly, though both will seek to create a hash of item id keys mapped to target measure values, either total item sales or total item profits.

The method `#most_sold_items_per_merchant` declares a new variable `item_measure` as an empty hash. This will eventually be populated with keys that are Item ID's, who's values will represent the sums of the numbers of those items sold. To accomplish this, we iterate over the entire array of profitable invoice items. For each `InvoiceItem`, we take the item_id attribute and query `item_measure` for a corrisponding key. Through a turnary statment, if the key does not exist, we instantiate the key and set its value equal to that `InvoiceItem`'s quantity. If the key already exists, its value is incremented by the `InvoiceItem`'s quantity attribute.

The method `#best_item_for_merchant` will also create an empty hash, to be filled similarly with keys corrisponding to Item ID's. The corresponding values for this mehtod though will be profit made from those items, as calculated from each `Invoice Item` by multiplying its `unit_price` attribute by its `quantity` attribute.

Both methods now have a hash pairing item ID's to target measures, called `item_measure`. We now instantiate a new hash, `max_measure`, with keys holding default values of a 0 measure, and an empty array of items (mapped to keys `:measure` and `:items` respectively). We pass both these hashes to the final helper method, `helper_get_greatest_measure` which will extract the key corresponding to the greatest value.

`helper_get_greatest_measure` will iterate over every key/value pair in `item_measure`, comparing each value to the value of `max_item`'s `measure` value. `max_item` will remember the greater value, and its item ID as an array. Or, if the values are equal, it will add that item ID to the array (if a new, greater value is found later, it will forget all stored ID's and remember only the new ID). Finally, the function outputs the array of item ID's from `max_item`, remapped as corresponding Item instances. When output from `#most_sold_items_per_merchant`, these should represent the item(s) with the greates number of sales. From `#best_item_for_merchant`, item(s) with the most profitable sales. 
